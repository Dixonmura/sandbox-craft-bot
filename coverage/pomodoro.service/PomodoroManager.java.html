<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="ru"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PomodoroManager.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Java TelegramAPI Module</a> &gt; <a href="index.source.html" class="el_package">pomodoro.service</a> &gt; <span class="el_source">PomodoroManager.java</span></div><h1>PomodoroManager.java</h1><pre class="source lang-java linenums">package pomodoro.service;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import pomodoro.core.*;

import java.time.Duration;
import java.time.Instant;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.ThreadLocalRandom;

/**
 * Управляет PomodoroSession:
 * Контролирует фазы сессии, выдаёт мотивирующее фото с сообщением в соответствующей фазе
 */
public class PomodoroManager {

<span class="fc" id="L20">    private static final Logger log = LogManager.getLogger(PomodoroManager.class);</span>
<span class="fc" id="L21">    private static final Duration MAX_SESSION_DURATION = Duration.ofHours(16);</span>
    private final Map&lt;Long, ScheduledFuture&lt;?&gt;&gt; scheduledTasks;
    private final Map&lt;Phase, List&lt;MotivationPhoto&gt;&gt; motivationPhotos;
    private final Map&lt;Long, PomodoroSession&gt; sessions;
    private final Map&lt;Long, PomodoroServiceSettings&gt; settings;

<span class="fc" id="L27">    public PomodoroManager(Map&lt;Phase, List&lt;MotivationPhoto&gt;&gt; motivationPhotos) {</span>
<span class="fc bfc" id="L28" title="All 4 branches covered.">        if (motivationPhotos == null || motivationPhotos.isEmpty()) {</span>
<span class="fc" id="L29">            log.error(&quot;Попытка создать PomodoroManager, когда motivationPhoto пустой или null&quot;);</span>
<span class="fc" id="L30">            throw new IllegalArgumentException(&quot;motivationPhotos не может быть пустым или null&quot;);</span>
        }

<span class="fc" id="L33">        this.motivationPhotos = motivationPhotos;</span>
<span class="fc" id="L34">        this.settings = new ConcurrentHashMap&lt;&gt;();</span>
<span class="fc" id="L35">        this.scheduledTasks = new ConcurrentHashMap&lt;&gt;();</span>
<span class="fc" id="L36">        this.sessions = new ConcurrentHashMap&lt;&gt;();</span>
<span class="fc" id="L37">    }</span>

    /**
     * Запускает сессию для фазы работы
     *
     * @param chatId идентификатор пользователя
     */
    public void startWorkSession(Long chatId, Duration phaseDuration) {
<span class="fc" id="L45">        PomodoroSession session = sessions.get(chatId);</span>
<span class="fc" id="L46">        session.setCurrentPhase(Phase.WORK);</span>
<span class="fc" id="L47">        session.startCurrentPhase(phaseDuration);</span>
<span class="fc" id="L48">    }</span>

    /**
     * Запускает сессию для фазы короткого отдыха
     *
     * @param chatId идентификатор пользователя
     */
    public void startShortRestSession(Long chatId, Duration phaseDuration) {
<span class="fc" id="L56">        PomodoroSession session = sessions.get(chatId);</span>
<span class="fc" id="L57">        session.setCurrentPhase(Phase.SHORT_BREAK);</span>
<span class="fc" id="L58">        session.startCurrentPhase(phaseDuration);</span>
<span class="fc" id="L59">    }</span>

    /**
     * Запускает сессию для фазы длинного отдыха
     *
     * @param chatId идентификатор пользователя
     */
    public void startLongRestSession(Long chatId, Duration phaseDuration) {
<span class="fc" id="L67">        PomodoroSession session = sessions.get(chatId);</span>
<span class="fc" id="L68">        session.setCurrentPhase(Phase.LONG_BREAK);</span>
<span class="fc" id="L69">        session.startCurrentPhase(phaseDuration);</span>
<span class="fc" id="L70">    }</span>

    /**
     * Выбирает список мотивационную фотографию согласно текущей фазы сессии
     *
     * @param session текущая сессия
     * @return случайное мотивирующее фото из списка для текущей фазы
     */
    public MotivationPhoto chooseMotivationForSession(PomodoroSession session) {
<span class="fc" id="L79">        Phase phase = session.getCurrentPhase();</span>
<span class="fc" id="L80">        List&lt;MotivationPhoto&gt; listMotivations = motivationPhotos.get(phase);</span>
<span class="pc bpc" id="L81" title="1 of 4 branches missed.">        if (listMotivations == null || listMotivations.isEmpty()) {</span>
<span class="fc" id="L82">            log.error(&quot;вызван метод chooseMotivationForSession, когда список мотивационных фото null или пустой&quot;);</span>
<span class="fc" id="L83">            throw new IllegalStateException(&quot;Нет мотивационных фото для фазы &quot; + phase);</span>
        }
<span class="fc" id="L85">        int index = ThreadLocalRandom.current().nextInt(listMotivations.size());</span>
<span class="fc" id="L86">        return listMotivations.get(index);</span>
    }

    /**
     * Проверяет, когда пользователь должен сделать длинный перерыв
     *
     * @param session текущая сессия
     * @return результат проверки опираясь на количество пройденных рабочих циклов
     */
    public boolean shouldStartLongBreak(PomodoroSession session, Long chatId) {
<span class="fc" id="L96">        int cycles = session.getCompleteWorkingCycles();</span>
<span class="fc" id="L97">        int cyclesBeforeLongBreak = settings.get(chatId).sessionsBeforeLongBreak();</span>
<span class="pc bpc" id="L98" title="1 of 4 branches missed.">        return cycles &gt; 0 &amp;&amp; cycles % cyclesBeforeLongBreak == 0;</span>
    }

    /**
     * Определяет следующую фазу по текущей фазе и количеству пройденных рабочих циклов
     *
     * @param session текущая сессия
     * @return следующую фазу исходя из секущей фазы сессии
     */
    public Phase getNextPhase(PomodoroSession session, Long chatId) {
<span class="fc" id="L108">        Phase currentPhase = session.getCurrentPhase();</span>
<span class="fc bfc" id="L109" title="All 2 branches covered.">        return switch (currentPhase) {</span>
<span class="fc bfc" id="L110" title="All 2 branches covered.">            case WORK -&gt; (shouldStartLongBreak(session, chatId)) ? Phase.LONG_BREAK : Phase.SHORT_BREAK;</span>
<span class="fc" id="L111">            case LONG_BREAK, SHORT_BREAK -&gt; Phase.WORK;</span>
        };
    }

    /**
     * Использует количество пройденных рабочих циклов сессии
     *
     * @param session текущая сессия
     * @return ранг, соответствующий количеству пройденных рабочих циклов
     */
    public String calculateRank(PomodoroSession session) {
<span class="fc" id="L122">        int cycles = session.getCompleteWorkingCycles();</span>
<span class="fc" id="L123">        return PomodoroRank.fromCycles(cycles).title();</span>
    }

    /**
     * Проверяет прошло ли максимальное время существования сессии
     * сравнивая прошедший период времени с максимально установленным
     */
    public boolean isOverLimit(PomodoroSession session) {
<span class="fc" id="L131">        return Duration.between(session.getStartTime(), Instant.now())</span>
<span class="fc bfc" id="L132" title="All 2 branches covered.">                .compareTo(MAX_SESSION_DURATION) &gt;= 0;</span>
    }

    /**
     * Опираясь на фиксированный лимит времени жизни сессии
     * по достижении указанного промежутка времени, заблаговременно
     * предупреждает пользователя о скором закрытии сессии по лимиту времени
     */
    public boolean isCloseToLimit(PomodoroSession session, Duration warnBefore) {
<span class="fc" id="L141">        Duration elapsed = Duration.between(session.getStartTime(), Instant.now());</span>
<span class="pc bpc" id="L142" title="1 of 2 branches missed.">        return elapsed.compareTo(MAX_SESSION_DURATION.minus(warnBefore)) &gt;= 0;</span>
    }

    /**
     * Удаляет существующую сессию по chatId
     */
    public void endSession(Long chatId) {
<span class="pc bpc" id="L149" title="1 of 2 branches missed.">        if (sessions.get(chatId) != null) {</span>
<span class="fc" id="L150">            sessions.remove(chatId);</span>
        } else {
<span class="nc" id="L152">            log.warn(&quot;Попытка удаления несуществующей сессии по chatId={}&quot;, chatId);</span>
        }
<span class="fc" id="L154">    }</span>

    /**
     * Отменяет действующую задачу в планировщике
     */
    public void cancelFuture(Long chatId) {
<span class="fc" id="L160">        ScheduledFuture&lt;?&gt; future = scheduledTasks.remove(chatId);</span>
<span class="fc bfc" id="L161" title="All 2 branches covered.">        if (future != null) {</span>
<span class="fc" id="L162">            future.cancel(false);</span>
        }
<span class="fc" id="L164">    }</span>

    /**
     * Добавляет сессию в список сессий
     */
    public void addSession(Long chatId, PomodoroSession session) {
<span class="fc" id="L170">        session.setState(SessionState.SETUP);</span>
<span class="fc" id="L171">        sessions.put(chatId, session);</span>
<span class="fc" id="L172">    }</span>

    public boolean hasActiveSession(Long chatId) {
<span class="fc" id="L175">        PomodoroSession session = sessions.get(chatId);</span>
<span class="pc bpc" id="L176" title="2 of 4 branches missed.">        return session != null &amp;&amp; !session.isFinished();</span>
    }

    public void saveFuture(Long chatId, ScheduledFuture&lt;?&gt; future) {
<span class="fc" id="L180">        scheduledTasks.put(chatId, future);</span>
<span class="fc" id="L181">    }</span>

    public PomodoroServiceSettings getSettings(Long chatId) {
<span class="fc" id="L184">        return settings.get(chatId);</span>
    }

    public PomodoroSession getSession(Long chatId) {
<span class="fc bfc" id="L188" title="All 2 branches covered.">        if (sessions.get(chatId) == null) {</span>
<span class="fc" id="L189">            throw new IllegalStateException(&quot;Невозможно получить сессию до её добавления в список&quot;);</span>
        }
<span class="fc" id="L191">        return sessions.get(chatId);</span>
    }

    public void setSettings(Long chatId, PomodoroServiceSettings pomodoroServiceSettings) {
<span class="fc" id="L195">        settings.put(chatId, pomodoroServiceSettings);</span>
<span class="fc" id="L196">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>